the python language reference
    this reference manual describes the syntax and "core semantics"(核心语义) of the language ,it is terse(简洁),but attempts to be exact and complete.

introduction 
    alternate(替代) implementations
        CPython 
        PyPy
        Jython
    notation(符号)
        the descriptions of lexical analysis and syntax use a modified BNF(Backus-Naur Form:通用的，能严格表示语法规则，且所描述的语言与上下文无关，简单、明确，便于词法，语法分析) grammar notation.
        some rules
            ::= ：是“被定义为”的意思
            "..."：终结符，即引号中的字符序列本身，并非指代其它字。
            double_quote ：代表终结符 双引号 "
            <...>：必选项
            [...]：可选
            {...}：重复,0 或 任意次重复
            (...)：分组
            |：替换，即 或 的意思
            ...：表示各种列举或省略的代码片断
        this uses the following style of definition:
            name      ::=  lc_letter (lc_letter | "_")*
            lc_letter ::=  "a"..."z"
lexical analysis
    a python program is read by parser. input to the parser is a stream of tokens, generated by the lexical analyzer.this chapter describes how the lexical analyzer breaks a file into tokens.
    
    line structure
        a python program is divided into a number of logical lines.
    
    logical lines   
        the end of a logical line is represented by the token NEWLINE.
        statements(语句) cannot cross logical line boundaries except where NEWLINE is allowed by the syntax.
        a logical line is constructed from one or more physical lines by following the explicit or implicit line joining rules(线路连接规则). 
    
    physical lines
        a physical line is a sequence of characters terminated by an end-of-line sequence.

    comments
        a comments starts with a hash character(#)that is not part of a string literal. 
        a comments signifies(表示) the end of the logical line unless the implicit line joining rules are invoked(调用).
        comments are ignored by the syntax.

    encoding declarations(编码声明)
        the encoding declarations must appear on a line of its own,if it is the second line ,the first line must also be a comment only-line.
        such as:
                #!/usr/bin/python
                # -*- coding: utf8 -*-
    explicit line joining
        two or more physical lines may be joined into logical lines using backslash(\).
        such as:
            if 1900 < year < 2100 and 1 <= month <= 12 \
                and 1 <= day <= 31 and 0 <= hour < 24 \
                and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
                    return 1
        a line ending in a backslash cannot carry a moment.
    implicit line joining 
        expressions in parentheses:()  ,square brackets:[] ,curly braces:{} can be split over more than one physical line without using backslashes.
        such as:
            month_names = ['Januari', 'Februari', 'Maart',      # These are the
               'April',   'Mei',      'Juni',       # Dutch names
               'Juli',    'Augustus', 'September',  # for the months
               'Oktober', 'November', 'December']   # of the year

    indentation(缩进)
        leading whitespace(spaces and tabs) at the beginning of a logical line is used to compute the indentation level(缩进级别) of the line, which in turn(反过来) is used to determine the grouping of the statements(语句的分组) 
        Indentation cannot be split over multiple physical lines using backslashes
        the whitespace(空格) up to(直到) the first backslash determines the indentation
        here is an example of correctly (though confusingly) indented piece of python code:
            def perm(l):
                    # Compute the list of all permutations of l
                if len(l) <= 1:
                            return [l]
                r = []
                for i in range(len(l)):
                        s = l[:i] + l[i+1:]
                        p = perm(s)
                        for x in p:
                            r.append(l[i:i+1] + x)
                return r

    Other tokens
        Besides NEWLINE, INDENT and DEDENT, the following categories of tokens exist: 
            identifiers, keywords, literals, operators, and delimiters(分隔符). 
        Whitespace characters (other than line terminators, discussed earlier) are not tokens, but serve to delimit tokens.

    Identifiers and keywords
        Identifiers are unlimited in length. Case is significant(案例意义重大)

    Keywords
        The following identifiers are used as reserved words(保留字), or keywords of the language, and cannot be used as ordinary identifiers. They must be spelled exactly as written here:
            False      await      else       import     pass
            None       break      except     in         raise
            True       class      finally    is         return
            and        continue   for        lambda     try
            as         def        from       nonlocal   while
            assert     del        global     not        with
            async      elif       if         or         yield
    
    Soft Keywords
        Some identifiers are only reserved under specific contexts.such as:match,case in new version 3.10 
    
    
    Reserved classes of identifiers(保留的标识符类别)
        Certain classes(某些类别) of identifiers (besides keywords) have special meanings
        These classes are identified by the pattern(模式) of leading(前导) and trailing underscope(尾随下划线) characters. 
            _* Not imported by from module import *
            _ In a case pattern within a match statement, _ is a soft keyword that denotes a wildcard(表示通配符); Elsewhere(在别处), _ is a regular identifier. It is often used to name “special” items, but it is not special to Python itself.
            __*__ System-defined names,These names are defined by the interpreter(解释器) and its implementation (including the standard library).
            __* Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a mangled form(损坏的形式) to help avoid name clashes between “private” attributes of base and derived classes.
    
    literal(字面量)
        Literals are notations(表示法) for constant values(常量值) of some built-in types(内置类型).  
        string and bytes literal    
            String literals are described by the following lexical definitions:
                stringliteral   ::=  [stringprefix](shortstring | longstring)
                stringprefix    ::=  "r" | "u" | "R" | "U" | "f" | "F"
                     | "fr" | "Fr" | "fR" | "FR" | "rf" | "rF" | "Rf" | "RF"
                shortstring     ::=  "'" shortstringitem* "'" | '"' shortstringitem* '"'
                longstring      ::=  "'''" longstringitem* "'''" | '"""' longstringitem* '"""'
                shortstringitem ::=  shortstringchar | stringescapeseq
                longstringitem  ::=  longstringchar | stringescapeseq
                shortstringchar ::=  <any source character except "\" or newline or the quote>
                longstringchar  ::=  <any source character except "\">
                stringescapeseq ::=  "\" <any source character>

            bytesliteral   ::=  bytesprefix(shortbytes | longbytes)
                bytesprefix    ::=  "b" | "B" | "br" | "Br" | "bR" | "BR" | "rb" | "rB" | "Rb" | "RB"
                shortbytes     ::=  "'" shortbytesitem* "'" | '"' shortbytesitem* '"'
                longbytes      ::=  "'''" longbytesitem* "'''" | '"""' longbytesitem* '"""'
                shortbytesitem ::=  shortbyteschar | bytesescapeseq
                longbytesitem  ::=  longbyteschar | bytesescapeseq
                shortbyteschar ::=  <any ASCII character except "\" or newline or the quote>
                longbyteschar  ::=  <any ASCII character except "\">
                bytesescapeseq ::=  "\" <any ASCII character>

            One syntactic restriction(句法限制) not indicated by these productions(这些生产式) is that whitespace is not allowed between the stringprefix or bytesprefix and the rest of the literal.
            The source character set is defined by the encoding declaration; it is UTF-8 if no encoding declaration is given in the source file;
            Bytes literals are always prefixed with 'b' or 'B'; they produce an instance of the bytes type instead of the str type.
            
            Multiple adjacent(相邻的) string or bytes literals (delimited(划界) by whitespace), possibly using different quoting conventions(引用公约), are allowed, and their meaning is the same as their concatenation. Thus, "hello" 'world' is equivalent to(相当于) "helloworld". This feature(这个特性) can be used to reduce the number of backslashes needed, to split long strings conveniently across long lines(方便地将长字符串分割成长线), or even to add comments to parts of strings, for example:
                re.compile("[A-Za-z_]"       # letter or underscore
                        "[A-Za-z0-9_]*"   # letter, digit or underscore
                            )
            Note that this feature is defined at the syntactical level, but implemented at compile time. The ‘+’ operator must be used to concatenate string expressions at run time. Also note that literal concatenation can use different quoting styles for each component (even mixing raw strings and triple quoted strings), and formatted string literals may be concatenated with plain string literals.
        Formatted string literals
           New in version 3.6
           ...
        Numeric literals
            There are three types of numeric literals: integers, floating point numbers, and imaginary numbers. There are no complex literals (complex numbers can be formed by adding a real number and an imaginary number).
            Integer literals
                Integer literals are described by the following lexical definitions:
                    integer      ::=  decinteger | bininteger | octinteger | hexinteger
                    decinteger   ::=  nonzerodigit (["_"] digit)* | "0"+ (["_"] "0")*
                    bininteger   ::=  "0" ("b" | "B") (["_"] bindigit)+
                    octinteger   ::=  "0" ("o" | "O") (["_"] octdigit)+
                    hexinteger   ::=  "0" ("x" | "X") (["_"] hexdigit)+
                    nonzerodigit ::=  "1"..."9"
                    digit        ::=  "0"..."9"
                    bindigit     ::=  "0" | "1"
                    octdigit     ::=  "0"..."7"
                    hexdigit     ::=  digit | "a"..."f" | "A"..."F"
                There is no limit for the length of integer literals apart from what can be stored in available memory.
                Underscores are ignored for determining the numeric value of the literal. They can be used to group digits for enhanced readability;One underscore can occur between digits, and after base specifiers like 0x.
                Note that leading zeros in a non-zero decimal number are not allowed. This is for disambiguation(消除歧义，名词) with C-style octal literals, which Python used before version 3.0.
                Some examples of integer literals:
                    7     2147483647                        0o177    0b100110111
                    3     79228162514264337593543950336     0o377    0xdeadbeef
                    100_000_000_000                   0b_1110_0101
            
            Floating point literals
                Floating point literals are described by the following lexical definitions:
                    floatnumber   ::=  pointfloat | exponentfloat
                    pointfloat    ::=  [digitpart] fraction | digitpart "."
                    exponentfloat ::=  (digitpart | pointfloat) exponent
                    digitpart     ::=  digit (["_"] digit)*
                    fraction      ::=  "." digitpart
                    exponent      ::=  ("e" | "E") ["+" | "-"] digitpart
                Note that the integer and exponent parts are always interpreted using radix 10(基数10). For example, 077e010 is legal, and denotes the same number as 77e10. The allowed range of floating point literals is implementation-dependent(取决于实现). As in integer literals, underscores are supported for digit grouping.
                Some examples of floating point literals:
                    3.14    10.    .001    1e100    3.14e-10    0e0    3.14_15_93

            Imaginary literals
                Imaginary literals are described by the following lexical definitions:
                    imagnumber ::=  (floatnumber | digitpart) ("j" | "J")
                To create a complex number with a nonzero real part, add a floating point number to it, e.g., (3+4j). 
                Some examples of imaginary literals:
                    3.14j   10.j    10j     .001j   1e100j   3.14e-10j   3.14_15_93j
            
            Operators(操作符)
                The following tokens are operators:
                    +       -       *       **      /       //      %      @
                    <<      >>      &       |       ^       ~       :=
                    <       >       <=      >=      ==      !=
            Delimiters(分隔符)
                The following tokens serve as delimiters in the grammar:
                    (       )       [       ]       {       }
                    ,       :       .       ;       @       =       ->
                    +=      -=      *=      /=      //=     %=      @=
                    &=      |=      ^=      >>=     <<=     **=
                The period(句点) can also occur in floating-point and imaginary literals. A sequence of three periods(...) has a special meaning as an ellipsis literal(省略号文字). 
                The following printing ASCII characters have special meaning as part of other tokens or are otherwise significant to the lexical analyzer:
                    '       "       #       \
                The following printing ASCII characters are not used in Python. Their occurrence outside string literals and comments is an unconditional error:
                    $       ?       `
data model 
    Objects,values,types
        Objects are Python's abstraction for data. All data in a Python program is represented by objects or by relations between objects.
        Every object has an identity(标识), a type(类型) and a value(值).
            identity:An object’s identity never changes once it has been created,you may think of it as the object’s address in memory;The ‘is’ operator compares the identity of two objects; the id() function returns an integer representing its identity.
                For CPython, id(x) is the memory address where x is stored.
            type:An object’s type determines the operations that the object supports and also defines the possible values for objects of that type. The type() function returns an object’s type (which is an object itself). Like its identity, an object’s type is also unchangeable.
                The value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable.
                    The value of an immutable container object that contains a reference to a mutable object can change when the latter’s value is changed; however the container is still considered(仍然被认为是) immutable, because the collection of objects it contains cannot be changed. So, immutability(不可变性) is not strictly the same as having an unchangeable value, it is more subtle(微妙的).
                An object’s mutability is determined by its type; 
                    for instance, numbers, strings and tuples are immutable, while dictionaries and lists are mutable.

execution model

the import system

expressions

simple statements

compound statements

top-level components

full grammar specification 
